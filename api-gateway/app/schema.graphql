scalar DateTime
scalar JSON

schema {
    query: Query
    mutation: Mutation
}



type Message {
    id: ID!
    thread: Thread!
    user_id: ID!
    type: String
    paths: [String]
    created_at: DateTime!
    updated_at: DateTime!
    deleted_at: DateTime
}

type MessagesPage {
    items: [Message!]!
    next_cursor: String
    has_more: Boolean!
}


enum ChannelType {
    public
    private
}

type ChannelMember {
    id: ID!
    joined_at: DateTime!
}

input ChannelMemberInput {
    id: ID!
    joined_at: DateTime!
}

input CreateChannelInput {
    name: String!
    owner_id: String!
    users: [ChannelMemberInput!]!
    channel_type: ChannelType!
}

type Channel {
    id: ID
    name: String!
    owner_id: String!
    users: [ChannelMember!]!
    is_active: Boolean!
    channel_type: ChannelType!
    created_at: DateTime!
    updated_at: DateTime!
    deleted_at: DateTime
}

type ChannelBasicInfo {
    id: ID
    name: String!
    owner_id: String!
    channel_type: ChannelType!
    created_at: DateTime!
    user_count: Int!
}



type User {
    id: ID!
    email: String!
    username: String!
    full_name: String
    is_active: Boolean!
}

type Token {
    access_token: String!
    token_type: String!
}


type PrograChatbotReply {
    reply: String!
}

type WikipediaChatbotReply {
    message: String!
}




enum StatusEnum {
    online
    offline
}

enum DeviceEnum {
    web
    mobile
    desktop
    unknown
}

type UserPresence {
    id: ID!
    userId: ID!
    device: DeviceEnum!
    status: StatusEnum!
    connectedAt: DateTime!
    lastSeen: DateTime!
}

type DataPresenceReply {
    total_users: Int
    users: [UserPresence]
}

type GetPresenceReply {
    status: String!
    message: String!
    data: DataPresenceReply
}


type DataPresenceStatsReply {
    total: Int!
    online: Int!
    offline: Int!
}

type GetPresenceStatsReply {
    status: String!
    message: String!
    data: DataPresenceStatsReply
}

type GetPresenceUserReply {
    status: String!
    message: String!
    data: UserPresence
}


type DataRegisterPresence {
    userId: ID!
    device: DeviceEnum!
    status: StatusEnum!
    connectedAt: DateTime!
    lastSeen: DateTime!
}

type RegisterPresenceReply {
    status: String!
    message: String!
    data: DataRegisterPresence!
}

type UpdateDeletePresenceReply {
    status: String!
    message: String!
    data: String
}


type Thread {
    id: String!
    channel_id: String!
    title: String!
    created_by: String!
    status: String!
    meta: JSON
    created_at: DateTime!
    updated_at: DateTime
}


type Query {
    getMessage(thread_id: String!, user_id: String!): MessagesPage!

    getChannels: [ChannelBasicInfo!]!
    getChannel(channel_id: String!): Channel!

    getThread(thread_id: String!): Thread
    getThreads(channel_id: String): [Thread]

    getUser(token: String!): User!

    getMessagePrograChatbot(message: String!): PrograChatbotReply!
    getMessageWikipediaChatbot(message: String!): WikipediaChatbotReply!

    getPresence(statusEnum: StatusEnum): GetPresenceReply!
    getPresenceStats: GetPresenceStatsReply!
    getPresenceUser(userId: String!): GetPresenceUserReply!

}

type Mutation {
    createMessage(thread_id: ID!, content: String!, type_: String!, paths: [String], user_id: String!): Message!
    updateMessage(thread_id: String!, message_id: String!, content: String!, type_: String!, paths: [String], user_id: String!): Message!
    deleteMessage(thread_id: String!, message_id: String!, user_id: String!): Boolean!

    createChannel(name: String!, owner_id: String!, users: [ChannelMemberInput!]!, channel_type: ChannelType!): Channel!
    updateChannel(channel_id: ID!, name: String!, owner_id: String!, channel_type: ChannelType!): Channel!
    deleteChannel(channel_id: ID!): ID!
    reactivateChannel(channel_id: ID!): ID!

    createThread(channel_id: String!, title: String!, created_by: String!, meta: JSON): Thread!
    updateThread(thread_id: String!, title: String, status: String, meta: JSON): Thread!
    archiveThread(thread_id: String!): Thread!
    deleteThread(thread_id: String!): Boolean!

    createUser(email: String!, username: String!, password: String!, full_name: String): User!
    updateUser(full_name: String): User!
    loginUser(username_or_email: String!, password: String!): Token!

    registerPresence(userId: String!, device: DeviceEnum, ip: String): RegisterPresenceReply!
    updatePresence(userId: String!, status: StatusEnum, heartbeat: Boolean): UpdateDeletePresenceReply!
    deletePresence(userId: String!): UpdateDeletePresenceReply!
}







extend type Query {
  # HomePage -> search channels by query string
  searchChannels(
    q: String
    channel_id: ID
    owner_id: String
    channel_type: ChannelType
    is_active: Boolean
    limit: Int 
    offset: Int
    ): [Channel!]!

  # ChannelPage -> search threads within a channel using multiple optional filters.
 
  searchThreads(
    channel_id: String
    category: String
    author: String
    tag: String
    keyword: String
    start_date: DateTime
    end_date: DateTime
  ): [Thread!]!

    # ThreadPage -> search messages inside a thread
    searchMessages(thread_id: ID!, query: String): [Message!]!
}

# -------------------- Tipos para Moderación --------------------
type ChannelStats {
    channel_id: ID!
    total_violations: Int!
    banned_users: Int! # Total de usuarios actualmente baneados (perm + temp)
    perm_banned: Int!
    temp_banned: Int!
    total_users_with_strikes: Int! # Usuarios que tienen al menos un strike
    avg_strikes: Float! # El promedio de strikes
}

type ViolationBreakdown {
    high: Int!
    low: Int!
    medium: Int!
}

type ViolationSummary {
    total: Int!
    last_violation: DateTime
    by_severity: ViolationBreakdown!
}

type UserModerationFullStatus {
    user_id: ID!
    channel_id: ID!
    is_banned: Boolean!
    strike_count: Int! 
    violation_summary: ViolationSummary!
}

input CreateBlacklistWordInput {
    word: String!
    category: String
    is_regex: Boolean
    language: String
    notes: String
    severity: String
}

type AddBlacklistWordResult {
    id: ID!
    success: Boolean!
    message: String
}

type BlacklistWord {
    id: ID!
    word: String!
    added_at: DateTime!
    added_by: ID! 
    is_active: Boolean!
    category: String 
}

type BlacklistPage {
    total: Int!
    words: [BlacklistWord!]!
}

type ModerationStatus {
    channel_id: ID!
    is_banned: Boolean!
    last_violation: DateTime
    strike_count: Int!        # Número de advertencias acumuladas
    strikes_reset_at: DateTime
    user_id: ID!
}

type Violation {
    id: ID!
    message_id: ID!
    action_taken: String! # Ej: warning, ban, strike
    detected_words: [String!]
    timestamp: DateTime!
}

type UserViolationSummary {
    user_id: ID!
    channel_id: ID!
    is_banned: Boolean!
    total_violations: Int!
    current_strikes: Int! # El servicio REST lo llama así
    violations: [Violation!]! # El array del historial
}

type BlacklistStats {
    total_words: Int!
    last_refresh_at: DateTime!
}



extend type Query {
    # Para el frontend: Obtiene si un usuario está baneado en un canal y sus strikes.
    getUserChannelStatus(user_id: ID!, channel_id: ID!): ModerationStatus!

    # ADMIN: Lista las palabras prohibidas.
    listBlacklistWords(
        language: String
        category: String
        severity: String
        limit: Int = 50
        skip: Int = 0

    ): BlacklistPage

    # ADMIN: Estadísticas de la Blacklist.
    getBlacklistStats: BlacklistStats!

    # ADMIN: Lista de usuarios actualmente baneados.
    listBannedUsers: [ModerationStatus!]! # Usamos ModerationStatus para reutilizar.

    # ADMIN: Historial de violaciones de un usuario.
    getUserViolations(user_id: ID!, channel_id: ID!): UserViolationSummary

    # ADMIN: Estado completo de moderación de un usuario.
    getUserModerationStatus(user_id: ID!): UserModerationFullStatus

    # ADMIN: Estadísticas de moderación de un canal.
    getChannelStats(channelId: ID!): ChannelStats
}

extend type Mutation {
    # ADMIN: Agrega una palabra a la lista negra.
    addBlacklistWord(data: CreateBlacklistWordInput!): AddBlacklistWordResult

    # ADMIN: Elimina una palabra de la lista negra.
    deleteBlacklistWord(word_id: ID!): Boolean!

    # ADMIN: Desbanea manualmente a un usuario.
    unbanUser(user_id: ID!): Boolean!

    # ADMIN: Resetea los strikes de un usuario.
    resetUserStrikes(user_id: ID!): Boolean!

    # ADMIN: Refresca el cache de palabras prohibidas.
    refreshBlacklistCache: Boolean!
}